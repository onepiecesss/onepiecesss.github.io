<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[ppx]]></title>
    <url>%2F2019%2F05%2F18%2Fppx%2F</url>
    <content type="text"><![CDATA[]]></content>
  </entry>
  <entry>
    <title><![CDATA[优先搜素]]></title>
    <url>%2F2019%2F05%2F11%2F%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A0%2F</url>
    <content type="text"><![CDATA[介绍优先搜素我们用一个图形搜素来进行一些解释和说明，我们先来看深度优先搜素找其最短路线，话不多说，上图， 其中五角星是障碍物，圆圈是我们的目标，怎么去找到这个圆圈呢，我们假设从一开始，它有两条路可选，一个是二一个是4，那我们假设每个点去找下一个点的时候用左、下、右上的顺序去找，我们用递归的方式来实现这个深度优先搜素;如图所示:我们来走一下这个流程图，我们的1点开始往下走首先经过一个判断，目标并不在1中，所以继续往下走会经历一个循环，第一步的循环是往左寻找，找到了2点，二点往下走判断过后被标记，然后进入fx()中进入递归，二点去进行判断后进入循环，此时循环执行了两次，第一次往左找并没有找到能通过的点，因为二点的左面是阻挡物，此时进入第二重循环找到了五接下来的操作就很类似…但有一个重点就是你要记住每层递归中循环到达了第几层循环和那些点已经被标记了，……然后我们呢=就到达了目标点，发现目标点return到上一步12点，而此时12点循环已经到了第三层，此时12点往下走解除目标点的标记进入第四层循环发现并没有找到可以通过的点(因为10点已经被标记了)，所以12这一层走到了最下边的return，归还到了10点并解除12点的标记，此时10点已经到了第二层循环，而且此时10点的后两层找不到可以通过的点，，所以十点也走到了return，到了7点并解除7点的标记，此时7点走到了第二层循环，然后在第四层循环找到了3点，所以把三点递归，发现3点找不到任何通道，(7点此时还在被标记)，然后又归还到了7点，7点的循环已经四层了，所以也走到了return，归还到了6点，并解除7点的标记，六点也找不到，所以又归还到了5点，并解除了6点的标记，到五点我们就找到了新的点就是9点，九点找到了8点，8点找到了11点，11点找到了13点，13-14-15-目标点，…我就找到这里了后面的操作和之前的差不多，最后会把所有的路径找到，最终得出一个最短路径。这就是深度优先搜素。 广度优先搜素：相对与深度优先搜素，广度优先搜索就显得直接一点，如图所示，我们还是从1开始，它会寻找周围所有可以通过的点，然后那些满足条件的点再去寻找周围所有满足的点，然后就会找到目标点，从上来看，广度优先需要一个可以存储点的容器，而且在点寻找点的的时候是先进先出的一种方式，所以这个容器就是队列，]]></content>
      <tags>
        <tag>image</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[福尔摩斯的约会]]></title>
    <url>%2F2019%2F04%2F26%2F%E7%A6%8F%E5%B0%94%E6%91%A9%E6%96%AF%2F</url>
    <content type="text"><![CDATA[一个pta上的题的一些感悟，我们先看一下题…… 福尔摩斯的约会： 大侦探福尔摩斯接到一张奇怪的字条：我们约会吧！ 3485djDkxh4hhGE 2984akDfkkkkggEdsb s&amp;hgsfdk d&amp;Hyscvnm。大侦探很快就明白了，字条上奇怪的乱码实际上就是约会的时间星期四 14:04，因为前面两字符串中第 1 对相同的大写英文字母（大小写有区分）是第 4 个字母 D，代表星期四；第 2 对相同的字符是 E ，那是第 5 个英文字母，代表一天里的第 14 个钟头（于是一天的 0 点到 23 点由数字 0 到 9、以及大写字母 A 到 N 表示）；后面两字符串第 1 对相同的英文字母 s 出现在第 4 个位置（从 0 开始计数）上，代表第 4 分钟。现给定两对字符串，请帮助福尔摩斯解码得到约会的时间。 输入格式：输入在 4 行中分别给出 4 个非空、不包含空格、且长度不超过 60 的字符串。 输出格式：在一行中输出约会的时间，格式为 DAY HH:MM，其中 DAY 是某星期的 3 字符缩写，即 MON 表示星期一，TUE 表示星期二，WED 表示星期三，THU 表示星期四，FRI 表示星期五，SAT 表示星期六，SUN 表示星期日。题目输入保证每个测试存在唯一解。 输入样例：3485djDkxh4hhGE2984akDfkkkkggEdsbs&amp;hgsfdkd&amp;Hyscvnm 最近写了不少的代码，就是在你动手写代码之前思路一定要清晰，这个题就告诉我们如果你上来就写，会越写越进坑，越写越迷糊，怎么样才能思路清晰呢，那就是审题的时候抓住让你疑惑的点，就如这个题， 第一个点就是前面两字符串中第 1 对相同的大写英文字母（大小写有区分）在这里就告诉我们我们的第一对字母必须是大写， 第二个点就是是第 4 个字母 D，代表星期四就是告诉我们第一对字母的范围是A-G，且对应着周一到周日， 第三个点是于是一天的 0 点到 23 点由数字 0 到 9、以及大写字母 A 到 N 表示告诉我们第二对相同的字符必须是0-9或者A-N, 第四个点是隐含的条件我们在输入里可以看到小时的字母是在星期字母之后的（在输入样例里第一对相同的是8，但是我们却没有取，证明小时的在星期之后） 这个条件就告诉我们在我们寻找字母的时候小时的寻找是在星期之后 第五个点后面两字符串第 1 对相同的英文字母，也就是后面两串必须是相同的英文字母，其出现的位置作为分； 第六个点也是隐含条件，就是这两对字母都有可能有多个满足条件的，所以当我们找到即退出循环 第七个点，小时和分钟小于两位数时要在前面补0 ok，上代码， import java.util.Scanner; public class Main { public static void main(String[]args) { Scanner sca=new Scanner(System.in); String a=sca.next(); String b=sca.next(); String c=sca.next(); String d=sca.next(); char Day=&apos; &apos;; int Hour=0; int MM=0; int k=0;//用来标记取了星期后的位置 //取星期 for(int i=0;i&lt;a.length()&amp;&amp;i&lt;b.length();i++){ if(a.charAt(i)==b.charAt(i)){ if(a.charAt(i)&gt;=&apos;A&apos;&amp;&amp;a.charAt(i)&lt;=&apos;G&apos;){ Day=a.charAt(i); k=i; break; } } } //取小时 for(int i=k+1;i&lt;a.length()&amp;&amp;i&lt;b.length();i++){ if(a.charAt(i)==b.charAt(i)){ if(a.charAt(i)&gt;=&apos;A&apos;&amp;&amp;a.charAt(i)&lt;=&apos;N&apos;){ Hour=a.charAt(i)-&apos;A&apos;+10; break; } if(a.charAt(i)&lt;=&apos;9&apos;&amp;&amp;a.charAt(i)&gt;=&apos;0&apos;){ Hour=a.charAt(i)-&apos;0&apos;; break; } } } //取分钟 for(int i=0;i&lt;c.length()&amp;&amp;i&lt;d.length();i++){ if(c.charAt(i)==d.charAt(i)){ if(c.charAt(i)&gt;=&apos;a&apos;&amp;&amp;c.charAt(i)&lt;=&apos;z&apos;||c.charAt(i)&gt;=&apos;A&apos;&amp;&amp;c.charAt(i)&lt;=&apos;Z&apos;) { MM=i; break; } } } switch (Day) { case &apos;A&apos;: System.out.print(&quot;MON&quot; + &quot; &quot;); break; case &apos;B&apos;: System.out.print(&quot;TUE&quot; + &quot; &quot;); break; case &apos;C&apos;: System.out.print(&quot;WED&quot; + &quot; &quot;); break; case &apos;D&apos;: System.out.print(&quot;THU&quot; + &quot; &quot;); break; case &apos;E&apos;: System.out.print(&quot;FRI&quot; + &quot; &quot;); break; case &apos;F&apos;: System.out.print(&quot;SAT&quot; + &quot; &quot;); break; case &apos;G&apos;: System.out.print(&quot;SUN&quot; + &quot; &quot;); break; } if(Hour&lt;10){ System.out.print(&quot;0&quot;+Hour+&quot;:&quot;); } else { System.out.print(Hour+&quot;:&quot;); } if(MM&lt;10){ System.out.print(&quot;0&quot;+MM); } else { System.out.print(MM); } } }]]></content>
  </entry>
  <entry>
    <title><![CDATA[idea]]></title>
    <url>%2F2019%2F04%2F17%2FNewworld%2F</url>
    <content type="text"><![CDATA[浅谈数据结构与算法数据结构:简单来说，就是一种存储数据的工具，对于不同的数据结构，有着各自的优势与局限，比如数组，数组是一个相对简单的数据结构，他的优势在于在知道数组下标的时候可以直接命中，而局限就是静态，不能自主的扩大和缩小空间，会导致内存空间的浪费…… 算法:任何良定义的计算过程，我记得在我刚入门的时候有人对我说过，学计算机最后学的是数学，起初我还觉得just so so，但是进入算法后，每天都像是在做奥数一样，终于恍然大悟，算法里的思想大多都是数学里过来的，列入数学归纳法、循环不变式…各式各样的算法思维几乎都是数学演变过来的，不过我想说的是：在如今的计算机领域里算法领域的人才仍旧很稀缺，因为它很难，“算法更像一个眼睛，他能让我们看到不一样的世界”。说了一堆没用话，算是自己的一些感悟吧ok，接下来让我们看看这两者之间的关系，我们从一个列子上来说：排序，如果你只知道排序算法，而不知道数据结构，那你根本无法对n个数进行排序，数据结构对于算法来说是一个工具，算法对于数据结构来说就是使用工具的人，在排序算法里我们注重时间复杂度，我们先看一个比较慢的排序-插入排序 public class 插入排序 { public static void main(String[]args){ int ar[]={5,6,2,3,4,8}; for(int j=1;j&lt;ar.length;j++){ int k=ar[j]; int i=j-1; while(i&gt;=0){ if(ar[i]&gt;k){ ar[i+1]=ar[i]; ar[i]=k; } i--; } } for(int i=0;i&lt;ar.length;i++){ System.out.print(ar[i]); } } } 插入排序就像是一副牌在桌子上你的任务就是从桌子上把牌一张一张的拿起来把它从小到大或者从大到小一个个的比对并放入手中，这里边就有个有意思的点，就是当你每次从桌面上之前你的手里是已经排好序的，这就是循环不变式，循环不变式有三个点，满足则为循环不变式，不满足则不是，初始化：在第一次迭代之前，循环不变式为真保持：如果某次迭代之前循环不变式为真，那么下一次也为真终止：循环不变式可以用来验证我们的算法是正确的其实循环不变式是来自于数学归纳法，插入排序的时间复杂度是o(n*2)，我们在看一个快牌，也叫二分法排序， public class 快排 { int ar[]=new int[]{1,4,3,2}; public void k(int left,int right){ if(left&gt;right) return; int i=left; int j=right; int temp=ar[left]; while(i!=j){ while (ar[j]&gt;=temp&amp;&amp;i&lt;j){ j--; } while (ar[i]&lt;=temp&amp;&amp;i&lt;j){ i++; } if(i&lt;j){ int aug=ar[j]; ar[j]=ar[i]; ar[i]=aug; } } ar[left]=ar[i]; ar[i]=temp; k(left,i-1); k(i+1,right); return; } public static void main(String[]args){ 快排 op=new 快排(); op.k(0,3 ); for(int i=0;i&lt;op.ar.length;i++){ System.out.println(op.ar[i]); } } } 快排主要的思想就是二分法排序，先找一个中间点，把比这个中间点小的放在左面，大的放在左面，反之亦然，然后依次放置，快排的时间复杂度为o(nlog(n)),显然我们对于这两种算法，当n比较大时，差距是很大的，当快排需要不到一秒的时间就可以排好，插入排序需要几个小时甚至是几天……对与同样的数据结构采用不同的算法，差距是很显著的，所以算法的有效使用对数据结构来讲是非常重要的。反之亦然，一个最合适的数据结构对算法的帮助和实行也是必不可少的]]></content>
  </entry>
  <entry>
    <title><![CDATA[学生教务管理系统]]></title>
    <url>%2F2018%2F09%2F30%2F%E5%AD%A6%E7%94%9F%E6%95%99%E5%8A%A1%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F%2F</url>
    <content type="text"><![CDATA[第一次接触web开发，用的语言是c#，开发工具 vs2017和asp.net，数据库我用的是sql，ok，let’s goasp.net是一个比较老的开发工具，里面给的控件界面很丑，还好有两个兄弟帮我改了那些界面，asp.net虽然很老，但是他简单啊，对于一个第一次web开发算是可以了，但是里面还是有些不少的坑，毕竟用人家的东西要遵守人家的规则， 首先，我们需要做一些需求分析，这个因为做的比较简单，像建模啊、数据流图、数据字典等就不说了，直接从功能来分析我们要准备什么吧主体：学生、教师和管理员管理员具有的功能：增删改查学生、教师和课程的信息，可以查看学生的成绩，还可以修改自己的密码，教师具有的功能：可以查看自己的任课信息（谁选了自己的课），可以给自己的学生上传成绩，修改自己的密码学生具有的功能：可以查看自己的成绩ok，功能已经说完，我们先安排一下数据库，第一步先画出ER图，根据ER图分析属性和联系，然后得出想要的表，把表尽可能的转变为第三范式总共有5个表，管理员凌驾一切之上，所以管理员不与剩下的四个表有任何联系，剩下的表分别为：学生表，选课表，课程表，教师表，为了方便我们对一些信息的查看，我们需要创建两个视图，这两个视图分别为用于管理员查看每门课的选修情况和用于管理员查看学生的平均成绩 想一下，分析一下老师的功能，可以查询自己任课信息，所以为了方便老师查看选修自己课的同学信息，我们可以创建个存储过程来实现可根据老师的教师号来查看选修自己课的学生的一些信息 学生可以查看自己的成绩，为了方便学生查看自己的成绩，我们可以创建个函数来实现这个功能 为了我们开发的顺利我们需要对asp.net的几个插件进行熟悉lable button textbox DropDownList RadioButtonList GridView 我只用到了这些插件，因为功能有点多，可以百度，可以查书……. 前提准备工作已经做好，进入开发新建一个project，第一个界面如图所示，功能是实现管理员、教师和学生的登陆，后台的代码为： using System; using System.Collections.Generic; using System.Linq; using System.Web; using System.Web.UI; using System.Web.UI.WebControls; using System.Data.SqlClient;//在c#里这个叫命名空间，在java里叫做包，这个和下面的一起用来连接数据库，只针对sql， using System.Data; namespace WebApplication2 { public partial class login : System.Web.UI.Page { protected void Page_Load(object sender, EventArgs e) { } protected void Unnamed1_Click(object sender, EventArgs e) { //把用户输入的账号、密码和用来标记是学生还是教师还是管理员的值 string usterName = Tle_box.Text.Trim(); string usterPwd = Tlr_box1.Text.Trim(); string userRole = Rbr_st.SelectedValue.Trim();(这个是从DropDownList里根据用户选择的来取值) string strr = &quot;&quot;; switch (userRole) { case &quot;0&quot;: strr = &quot;select * from 学生 where 学生号=&apos;&quot; + usterName + &quot;&apos;&quot;; break; case &quot;1&quot;: strr = &quot;select * from 教师 where 教师号=&apos;&quot; + usterName + &quot;&apos;&quot;; break; case &quot;2&quot;: strr = &quot;select * from 管理员 where 管理员账号=&apos;&quot; + usterName + &quot;&apos;&quot;; break; } string str = &quot;server=DESKTOP-FT2EB7A;database=teachSystem;User id=sa;password=55555&quot;; SqlConnection coon = new SqlConnection(str);//连接数据库 SqlCommand cmd = new SqlCommand(strr, coon); coon.Open(); SqlDataReader sdr = cmd.ExecuteReader(); if (sdr.Read()) { if (sdr.GetString(1) == usterPwd) { //Session[]是个标记数组，这个数组可以进行数据的传递， Session[&quot;usterName&quot;] = usterName; Session[&quot;userRole&quot;] = userRole; coon.Close(); switch (userRole) { case &quot;0&quot;: Response.Redirect(&quot;up.aspx&quot;); break; case &quot;1&quot;: Response.Redirect(&quot;teacherSelect.aspx&quot;); break; case &quot;2&quot;: Response.Redirect(&quot;manage.aspx&quot;); break; } } else { Lab_text.Text = &quot;密码错误&quot;; } } else { Lab_text.Text = &quot;账号错误&quot;; } } } } 我在这里遇到的问题有两个，对数据库的操作语言不熟悉，这里有两个操作语言，第一个是连接SqlConnection，它主要用来连接的数据库，一个是命令语句SqlCommand，它用来执行sql语句命令，第二个问题是在进行密码验证时，这里用的是返回第二列的值，第二个界面如图：后端操作为 public partial class manage : System.Web.UI.Page { protected void Page_Load(object sender, EventArgs e) { } protected void Button1_Click(object sender, EventArgs e) { Response.Redirect(&quot;addStudent.aspx&quot;); } protected void Button2_Click(object sender, EventArgs e) { Response.Redirect(&quot;addTeacher.aspx&quot;); } protected void Button3_Click(object sender, EventArgs e) { Response.Redirect(&quot;addScource.aspx&quot;); } protected void Button4_Click(object sender, EventArgs e) { Response.Redirect(&quot;updateStudent.aspx&quot;); } protected void Button5_Click(object sender, EventArgs e) { Response.Redirect(&quot;updateTeacher.aspx&quot;); } protected void Button6_Click(object sender, EventArgs e) { Response.Redirect(&quot;updateSource.aspx&quot;); } protected void Button7_Click(object sender, EventArgs e) { Response.Redirect(&quot;selectXx.aspx&quot;); } protected void Button8_Click(object sender, EventArgs e) { Response.Redirect(&quot;selectAverage.aspx&quot;); } protected void Button9_Click(object sender, EventArgs e) { Response.Redirect(&quot;alter.aspx&quot;); } protected void Button10_Click(object sender, EventArgs e) { Response.Redirect(&quot;login.aspx&quot;); } } } 第三个界面是实现学生的添加，因为学生添加、老师添加、课程添加的后端代码类似，所以我只举一个列子来说明，界面如图 using System; using System.Collections.Generic; using System.Linq; using System.Web; using System.Web.UI; using System.Web.UI.WebControls; using System.Data.SqlClient; using System.Data; namespace WebApplication2 { public partial class addStudent : System.Web.UI.Page { protected void Page_Load(object sender, EventArgs e) { } protected void Button1_Click(object sender, EventArgs e) { string str= &quot;server=DESKTOP-FT2EB7A;database=teachSystem;User id=sa;password=55555&quot;; SqlConnection coon = new SqlConnection(str); string strr = &quot;insert into 学生 values(&apos;&quot; + TextBox1.Text + &quot;&apos;,&apos;&quot; + TextBox2.Text + &quot;&apos;,&apos;&quot;+TextBox3.Text+&quot;&apos;,&apos;&quot; + RadioButtonList1.Text + &quot;&apos;,&quot; + int.Parse(DropDownList1.SelectedValue) + &quot;,&apos;&quot; + DropDownList2.SelectedValue + &quot;&apos;)&quot;; SqlCommand cmd = new SqlCommand(strr, coon); coon.Open(); int flag = cmd.ExecuteNonQuery();//这个语句是执行上面的sql语句，并返回执行的列数， if (flag &gt; 0) { Label8.Text = &quot;添加成功&quot;; TextBox1.Text = &quot;&quot;; TextBox2.Text = &quot;&quot;; TextBox3.Text = &quot;&quot;; } else { Label8.Text = &quot;添加失败&quot;; } coon.Close(); } protected void Button2_Click(object sender, EventArgs e) { TextBox1.Text =&quot;&quot; ; TextBox2.Text = &quot;&quot;; TextBox3.Text = &quot;&quot;; } } }接下来是学生、教师和课程的更新和维护，界面如图：这里的功能我在控件加了一些语句进行实现的，用的控件是GridView和SqlDataSource这里是数据库绑定控件和数据源控件的合用，要熟悉这两个控件 接下来是管理员查看学生选修情况和查看学生的平均成绩，这里也是在控件加了一些语句进行实现的，用的控件是GridView和SqlDataSource这里的数据源控件SqlDataSource绑定的数据是视图不是表了 接下来是教师查看自己的任课信息，界面如图所示 后台代码 using System; using System.Collections.Generic; using System.Linq; using System.Web; using System.Web.UI; using System.Web.UI.WebControls; using System.Data; using System.Data.SqlClient; namespace WebApplication2 { public partial class select : System.Web.UI.Page { protected void Page_Load(object sender, EventArgs e) { if ((string)Session[&quot;userRole&quot;] != &quot;1&quot;)//判断是否为教师，如果不是回到主页面 { Response.Redirect(&quot;login.aspx&quot;); } if (!this.IsPostBack) { Label1.Text = &quot;请&quot; + (string)Session[&quot;techer&quot;] + &quot;选择你要查询的科目&quot;; Binddll(); binfffl(); } } private void Binddll() { string strr = &quot;server=DESKTOP-FT2EB7A;database=teachSystem;User id=sa;password=55555&quot;; SqlConnection coon = new SqlConnection(strr); SqlCommand cmd = coon.CreateCommand(); string std = &quot;select distinct 课程.课程号,课程.课程名 from 课程 where 教师号=&apos;&quot; + (string)Session[&quot;usterName&quot;] + &quot;&apos;&quot;; DataSet ds = new DataSet(); coon.Open(); SqlDataAdapter da = new SqlDataAdapter(std, coon); da.Fill(ds); DropDownList1.DataSource = ds.Tables[0].DefaultView; DropDownList1.DataTextField = &quot;课程名&quot;; DropDownList1.DataValueField = &quot;课程号&quot;; DropDownList1.DataBind(); } private void binfffl() { string strr = &quot;server=DESKTOP-FT2EB7A;database=teachSystem;User id=sa;password=55555&quot;; SqlConnection coon = new SqlConnection(strr); SqlCommand cmd = new SqlCommand(&quot;k_k_l&quot;, coon); cmd.CommandType = CommandType.StoredProcedure; cmd.Parameters.Add(&quot;@课程号&quot;, SqlDbType.VarChar, 6); cmd.Parameters[&quot;@课程号&quot;].Value = DropDownList1.SelectedValue.ToString(); coon.Open(); SqlDataReader dr = cmd.ExecuteReader(); GridView1.DataSource = dr; GridView1.DataBind(); coon.Close(); } protected void DropDownList1_SelectedIndexChanged(object sender, EventArgs e) { binfffl(); } 然后是教师录入学生的成绩，界面如图所示，后台代码为 using System; using System.Collections.Generic; using System.Linq; using System.Web; using System.Web.UI; using System.Web.UI.WebControls; using System.Data.SqlClient; using System.Data; namespace WebApplication2 { public partial class source : System.Web.UI.Page { protected void Page_Load(object sender, EventArgs e) { if ((string)Session[&quot;userRole&quot;] != &quot;1&quot;) { Response.Redirect(&quot;login.aspx&quot;); } if (!this.IsPostBack) { Label1.Text = &quot;请&quot; + (string)Session[&quot;techer&quot;] + &quot;老师选择要录入成绩的课程&quot;; Binddll(); binfffl(); } } private void Binddll() { string strr = &quot;server=DESKTOP-FT2EB7A;database=teachSystem;User id=sa;password=55555&quot;; SqlConnection coon = new SqlConnection(strr); SqlCommand cmd = coon.CreateCommand(); string std = &quot;select distinct 课程.课程号,课程.课程名 from 课程 where 教师号=&apos;&quot; + (string)Session[&quot;usterName&quot;] + &quot;&apos;&quot;; DataSet ds = new DataSet(); coon.Open(); SqlDataAdapter da = new SqlDataAdapter(std, coon); da.Fill(ds); DropDownList1.DataSource = ds.Tables[0].DefaultView; DropDownList1.DataTextField = &quot;课程名&quot;; DropDownList1.DataValueField = &quot;课程号&quot;; DropDownList1.DataBind(); } private void binfffl() { string strr = &quot;server=DESKTOP-FT2EB7A;database=teachSystem;User id=sa;password=55555&quot;; SqlConnection coon = new SqlConnection(strr); SqlCommand cmd = coon.CreateCommand(); cmd.CommandText = &quot;select 学生号,姓名,年级,专业,成绩 from 学生,课程,选修 where 学生.学生号=选修.学号 and 选修.课程号=课程.课程号 and 课程.课程号=&apos;&quot; + DropDownList1.SelectedValue + &quot;&apos;&quot;; coon.Open(); SqlDataReader dr = cmd.ExecuteReader(); GridView1.DataSource = dr; GridView1.DataBind(); coon.Close(); } protected void DropDownList1_SelectedIndexChanged(object sender, EventArgs e) { binfffl(); } protected void Button1_Click(object sender, EventArgs e) { string strr = &quot;server=DESKTOP-FT2EB7A;database=teachSystem;User id=sa;password=55555&quot;; SqlConnection coon = new SqlConnection(strr); SqlCommand cmd = coon.CreateCommand(); string strrd = DropDownList1.SelectedValue; coon.Open(); for (int i = 0; i &lt; GridView1.Rows.Count; i++) { int score = int.Parse(((TextBox)GridView1.Rows[i].FindControl(&quot;texscore&quot;)).Text.Trim()); string stuid = GridView1.Rows[i].Cells[0].Text; cmd.CommandText = &quot;update 选修 set 成绩=&apos;&quot; + score + &quot;&apos;where 学号=&apos;&quot; + stuid + &quot;&apos; and 课程号=&apos;&quot; + strrd + &quot;&apos; &quot;; cmd.ExecuteNonQuery(); } coon.Close(); Label2.Text = &quot;添加成功&quot;; } 然后是学生查看自己的成绩，界面如图，后台代码为 using System; using System.Collections.Generic; using System.Linq; using System.Web; using System.Web.UI; using System.Web.UI.WebControls; using System.Data; using System.Data.SqlClient; namespace WebApplication2 { public partial class up : System.Web.UI.Page { protected void Page_Load(object sender, EventArgs e) { if ((string)Session[&quot;userRole&quot;] != &quot;0&quot;) { Response.Redirect(&quot;login.aspx&quot;); } string strr = &quot;server=DESKTOP-FT2EB7A;database=teachSystem;User id=sa;password=55555&quot;; SqlConnection coon = new SqlConnection(strr); SqlCommand cmd = coon.CreateCommand(); cmd.CommandText = &quot;select * from stuscore( &quot;+ (string)Session[&quot;usterName&quot;] + &quot;)&quot;; coon.Open(); SqlDataReader dr = cmd.ExecuteReader(); GridView1.DataSource = dr; GridView1.DataBind(); dr.Close(); SqlCommand cmd1 = coon.CreateCommand(); cmd1.CommandText = &quot;select 姓名 from 学生 where 学生号=&apos;&quot; + (string)Session[&quot;usterName&quot;] + &quot;&apos;&quot;; SqlDataReader dr1 = cmd1.ExecuteReader(); dr1.Read(); Label1.Text = &quot;学生&quot; + (string)dr1[0] + &quot;的考试成绩&quot;; coon.Close(); } 最后修改自己的密码界面，界面如图所示，后台代码为： using System; using System.Collections.Generic; using System.Linq; using System.Web; using System.Web.UI; using System.Web.UI.WebControls; using System.Data.SqlClient; using System.Data; namespace WebApplication2 { public partial class alter : System.Web.UI.Page { protected void Page_Load(object sender, EventArgs e) { } protected void Button1_Click(object sender, EventArgs e) { string usterName = TextBox1.Text.Trim(); string usterrol = TextBox2.Text.Trim(); string newUster = TextBox3.Text.Trim(); string strr = &quot;&quot;; string strg = &quot;&quot;; string str = &quot;server=DESKTOP-FT2EB7A;database=teachSystem;User id=sa;password=55555&quot;; SqlConnection coon = new SqlConnection(str); switch (Session[&quot;userRole&quot;].ToString()) { case &quot;0&quot;: strr = &quot;select * from 学生 where 学生号=&apos;&quot; + usterName + &quot;&apos;&quot;; strg = &quot;update 学生 set 学生号=&apos;&quot; + usterName + &quot;&apos;,密码=&apos;&quot; + newUster + &quot;&apos; where 学生号=&apos;&quot; + usterName + &quot;&apos;&quot;; break; case &quot;1&quot;: strr = &quot;select * from 教师 where 教师号=&apos;&quot; + usterName + &quot;&apos;&quot;; strg = &quot;update 教师 set 教师号=&apos;&quot; + usterName + &quot;&apos;,密码=&apos;&quot; + newUster + &quot;&apos; where 教师号=&apos;&quot; + usterName + &quot;&apos;&quot;; break; case &quot;2&quot;: strr = &quot;select * from 管理员 where 管理员账号=&apos;&quot; + usterName + &quot;&apos;&quot;; strg = &quot;update 管理员 set 管理员账号=&apos;&quot; + usterName + &quot;&apos;,密码=&apos;&quot; + newUster + &quot;&apos; where 管理员账号=&apos;&quot; + usterName + &quot;&apos;&quot;; break; } SqlCommand cmd = new SqlCommand(strr, coon); coon.Open(); SqlDataReader strrr= cmd.ExecuteReader(); if (strrr.Read()) { if (strrr.GetString(1) == usterrol) { coon.Close(); SqlCommand updater = new SqlCommand(strg, coon); coon.Open(); updater.ExecuteNonQuery(); Label5.Text = &quot;修改成功&quot;; } else { Label5.Text = &quot;旧密码错误，请重新输入&quot;; } } else { Label5.Text = &quot;账号错误，请重新输入&quot;; } coon.Close(); } protected void Button2_Click(object sender, EventArgs e) { TextBox1.Text = &quot;&quot;; TextBox2.Text = &quot;&quot;; TextBox3.Text = &quot;&quot;; } } }]]></content>
  </entry>
  <entry>
    <title><![CDATA[飞机大战]]></title>
    <url>%2F2018%2F08%2F09%2F%E9%A3%9E%E6%9C%BA%E5%A4%A7%E6%88%98%2F</url>
    <content type="text"><![CDATA[最近，用java做了一个小游戏，飞机大战，借此来提升一下对java语音的深入了解，和对面向对象编程的进一步认识，ok，let’s do it！ 首先，我先简单说一下oo，用现实生活中的一个列子来说，一个立体声音音响系统，我们把其中的组件当作对象来看， 1 音响 2 低音喇叭 3 调谐器 4 CD播放器 5 唱机 这些组件能通过标准的输入/输出端子进行彼此交互，即使你买的这些组件不是同一个厂家，只要有标准的端子，就可以把它们组装成一个立体声音音响 系统， 面对对象的原理与此是相同的，其中每个对象都相当于一个组件，通过标准方式把它们组合在一起，每个对象都是在程序里扮演相应的角色。 ok，现在让我们看看飞机大战， 需求分析： 首先我需要的对象是： 1 我的本机Hero 2 敌机 3 蜜蜂 4 子弹 首先我想要的功能是 1 本机可以跟着鼠标移动 2 本机可以发出子弹，且子弹有双倍和单倍 3 敌机向下移动，且，当我的本机子弹打到敌机时，会得到相应的分数，且，敌机随之消失 4，蜜蜂左右下移动，且当我的本机子弹打到蜜蜂时，会得到生命值或双倍子弹 5 当敌、蜜蜂和我的本机碰撞时，会损失一条命， 代码实现阶段 为了减少代码量我们先创建一个抽象父类FlyingObject(用到了类的继承) 我们从Hero(本机)、敌机、蜜蜂这些类中分析到它们都需要坐标x，y， 和图片的width、hight，以及它们的贴图 image，我们把这些抽象到父类FlyingObject中，代码如下 public abstract class FlyingObject{ public int x; public int y; public int width; public int hight; public BufferedImage image;//贴图 public int getX(){ return x;//得到x的坐标 } public void setX(int x){ this.x=x;//用this将传进来的x赋值给坐标x； } public int getY(){ return y; } public void setY(){ this.y=y; } public int getWidth(){ return width; } public void setWidth(){ this,width=width; } public int getHight(){ return hight; } public void setHight(int hight){ this.hight=hight; } public BufferedImage getImage(){ return image; } public void setImage(){ this.image=image; } } 现在我们为各个对象创建属于它们的类 首先我们需要定义Enemy接口，用它来提供击中敌机时获的分数的方法，所以这个接口需要返回分数追； public interface Enemy(){ int getScore(); } 还需要定义一个奖励类型的接口；用它来提供击中Bee获得奖励的方法 public interface Award(){ int DOUBLIE_FIRE=0; int LIFE=1; //获取上面的类型的值； int getType(); } 创建第一个类Airplane；他需要继承父类FlyingObject，且有个Enemy的接口，敌机要向下移动所以还需要一个向下的速度的属性， public class Airplane extends FlyingObject implements enemy{ public int speed=2; public int getScore(){ return 0; } } 接下来是蜜蜂，首先蜜蜂要继承父类，其次蜜蜂要有奖励，所以有个奖励的接口，再其次蜜蜂是左右下移动，所以要有两个坐标速度的类型,最后还有一个奖励类型属性 public class Bee extends FlyingObject implements Award{ public int xSpeed; public int ySpeed; public int awrdType; public int getStype(){ return 0; } } 然后是子弹的类；子弹是向上移动的所以有个向上的速度类型；且继承父类 public class Bullet extends FlyingObject{ public int speed=2; } 接下来是hero，hero需要两张图片，因为当本机碰撞时会减去一条生命，这时就需要两张图片进行互换，所以我们需要定义一个数组来存储这两张图片； 其次英雄击中蜜蜂时有两个奖励，life和doublefire，所以把这两个也作为英雄机的属性； public class Hero extends FlyingObject(){ public BufferedImage [] image={}; public index=0;//用于hero照片互换的计数； public int DOUBLE_FIRE; public int life; } 现在我们需要一个类把我们对象对应的图片加载出来，新建一个ShootGame类，该类继承Jpanel，并使用静态常量来定义面板的宽和高， 并用ImageIO的read方法来加载图片，代码如下 public class ShootGame extends Jpanel{ public static final int width 400； public final final int hight 654； public static BufferedImage backgrount； public static BufferedImage airplane； public static BufferedImage bee； public static BufferedImage start； public static BufferedImage hero0； public static BufferedImage hero1； public static BufferedImage bullet； public static BufferedImage pause； public static BufferedImage gameover； static{ try{ backgrount=Image.read(ShootGame.class.getReSource(&quot;backgrount.png&quot;)); airplane=image.read(ShootGame.class.getResource(&quot;airplane.png&quot;)); start=image.read(ShootGame.class.getResource(&quot;start.png&quot;)); pause=image.read(ShootGame.class.getResource(&quot;pause.png&quot;)); hero0=image.read(ShootGame.class.getResource(&quot;hero0.png&quot;)); bullet=image.read(ShootGame.class.getResource(&quot;bullet.png&quot;)); her01=image.read(ShootGame.class.getResource(&quot;her01.png&quot;)); gameover=image.read(ShootGame.class.getResource(&quot;gameover.png&quot;));}catth(Exception e){ e.printStackTrace(); } } } 接下来初始化各对象 Hero的 public class Hero extends FlyingObject(){ public BufferedImage [] image={}; public index=0;//用于hero照片互换的计数； public int DOUBLE_FIRE; public int life; //初始化代码 public Hero(){ life=3; doublefire=0; this.image=ShootGame.hero0 image=new BufferedImage[ShootGame.hero0,ShootGame.hero1]; width=image.getWidth(); hight=image,getHight(); x=100; y=200; } } Airplane的 public class Airplane extends FlyingObject implements enemy{ public int speed=2; public Airplane(){ this.image=ShootGame.airplane; width=image.getWidth(); hight=image.getHight(); Y=-hight x=(int)(Math.random()*(ShootGame.WIDTH-width)); } public int getScore(){ return 0; } } Bee的 public class Bee extends FlyingObject implements Award{ public int xSpeed=1; public int ySpeed=2; public int awrdType; public Bee(){ this.image=ShootGame.bee; width=image.width; hight=image.hight; Random rand=new Random(); x=rand.nextInt(ShootGame.WIDTH-width); award=rand.next(2); } public int getStype(){ return 0; } } Bullet的 public class Bullet extends FlyingObject{ public int speed=2; //初始化 public Bullet(int x,int y){ this.x=x; this.y=y; this.image=ShootGame.bullet; } } 现在让我们初步实现一下，在ShootGame里添加main方法，在该方法中设置窗口的大小、居中、点击右上角的x关闭窗口，和实现窗口可视化， 在ShootGame类中添加以下代码； public static void main(String[]args){ JFrame frame=new JFrame(&quot;fly&quot;);//传进去的fly作为窗口名 ShootGame game=new ShootGame();//创建画板对象 frame.add(game); frame.setSize(WIDTH,HIGHT);//面板的宽度和高度， frame.setAlwaysOnTop(true);//让窗口总是保留在最前端， frame.setLocationRelativeTo(null);//设置窗口初始位置 //关闭窗口 frame.setDefultCloseOperation(JFrame.EXIT_ON_CLOSE); frame.setVisible(true);//尽快调用paint 此时可以运行一下ShootGame类会有个窗口出现，这里我就不贴图了ok，下一步，把我们的英雄机、飞行物和子弹绘制到我们的窗口里，在这里我多说两句数据结构的存在是为了方便我们更容易地对数据进行操作，所以，下面我把飞行物和子弹存储到数组里， private FlyingObject[]flying={}//敌机数组 private Bullet[]bullet={}//子弹数组 Hero hero= new Hero()//定义个英雄机对象， public ShootGame(){ flying=new FlyingObject[2];//分配两个空间 flying[0]=new Airplane(); flying[1]=new Bee(); bullet=new Bullet[1]; bullet[0]=new bullet(200,350); } 现在让我们开始绘画吧，还是在ShootGame里添加绘画代码， @Override public void paint(Graphics g){ g.drawImage(background,0,0,null);//画背景图， paintHero(g);//画英雄机 paintBullets(g);//画子弹 paintFlyingObjects(g);//画飞行物 } public void paintHero(Graphics g){ g.draeImage(hero.getImage(),getX,getY,null); } public void paintBullets(Graphics g) for(int i=0;i&lt;bullet.length;i++){ Bullet b=bullet[i]; g.draeImage(b.getImage(),getX,getY,null); } public void paintFlyingObjects(Graphics g)){ for(int i=0;i&lt;flying.length;i++) FlyingObject f= flying[i]; g.draeImage(f.getImage(),getX,getY,null); } ok,下一步就是重构一下Airplane和Bee的构造方法，也就是把他们的x，y确定下来，方便我们观察，这里我就不写代码了，贴一张成功的图， 下一步运行，实现飞行物的移动就是让他们的坐标随着我们定义的规则移动，首先在我们的父类里添加一个抽象方法， public abstract void styp(); 然后在各类飞行物里添加styp方法我举个子弹的，其他的可以去源码里找， 举个蜜蜂的，蜜蜂我们要让它左、右和下移动，所以在Bee类中添加 @Override public void styp(){ if(x&gt;ShootGame.WIDTH-width){ xSpeed=-1; } else if(x&lt;0){ xSpeed=1; } } 有个点要说一下，因为styp是定义在父类的抽象方法，所以他的子类必须要有这个方法， ok，下一步随机产生飞行物，这个飞行物可以是蜜蜂也可以是敌机， 在ShootGame类中添加， public static FlyingObject nextOne(){ Random rand=new Random(); int type=rand.nextInt(20);//0~19 if(type==0){ new Bee();} else{ new Airplane();} } 下一步实现飞行物的登场，在ShootGame类里添加enterAction，我想的是每调用四十次该方法登场一个蜜蜂或敌机， int flyEnteredIndex=0; public void enterAction(){ flyEnteredIndex++; if(flyEnteredIndex%40==0){ FlyingObject obj=nextOne(); flyling = Arrays.copyOf(flyling,flyling.length+1);//扩充数组 flying[flying.length-1]=obj; } } 下一步实现所有飞行物的移动，在ShootGame类中添加stepAction， public void stepAction(){ for(int i=0;i&lt;flying.length;i++){ FlyingObject f=flying[i]; f.step(); } for(int i=0;i&lt;bullet.length;i++){ Bullet b=bullet[i]; b.step(); } hero.step(); } 接下来，我们需要添加一个计时器，这个计时器的目的是辅助飞机物进场的时间间隔，so，我们需要在ShootGame里添加两个属性 private Timer timer； private int intervel=1000/100； //添加action方法，实现每隔十毫秒入场一个飞行物；并重新绘制页面 public void action(){ timer =new Timer();//主流程控制 timer.schedule(new TimerTask(){ @Override public void run(){ enterAction();//飞行物入场 stepAction();//走一步 repaint();//重绘 } } ,intervel,intervel); } 在ShootGame类的main方法里调用action game.action()； 现在你可以重构一下你的敌机、蜜蜂和子弹，把初始化里的x、y注释掉，你将会看到敌机会一直向下移动，蜜蜂斜着移动，子弹向上移动， ok，下一步我们来实现英雄机发射子弹，还记得我们在初始化子弹的时候子弹的x、y是我们传进去的，这个目的就是为了让子弹的位置固定到我们英雄机的发射子弹的位置，ok，在hero类中添加shoot方法， public bullet[] shoot(){ int xStpe=width/4; int yStpe=20; if(doublefire&gt;0){ Bullet bullet[]=new Bullet[2]; bullet[0]=new Bullet(x+xStep,y-yStep); bullet[1]= new Bullet(x+3*xStep,y-yStep); return bullet; } else Bullet bullet[]=new Bullet[1]; bullet[0]=new Bullet(x+2*xStep,y-yStep); return bullet; } 在ShootGame里添加shootAction方法目的是实现每三十毫秒打出一个子弹 int shootIndex=0; public void shootAction(){ shootIndex++; if(shootIndex%30==0){ Bullet []bs=hero.shoot();//英雄打出子弹 bullets=Arrays.copyOf(bullet,bullet.length+bs.length);//扩容 System.arraycopy(bs,0,bullets,bullet.length-bs.length,bs.length);//追加数组 } } 在action里调用shottAction方法 public void action(){ timer =new Timer();//主流程控制 timer.schedule(new TimerTask(){ @Override public void run(){ enterAction();//飞行物入场 stepAction();//走一步 shootAction(); repaint();//重绘 } } ,intervel,intervel); } 现在你可以运行一下，先把ShootGame初始化方法注释一下如下 public ShootGame(){ //flyling=new FlyingObject[2]; // flyling[0]=new AirPlane(); // flyling[1]=new Bee(); // bullets=new Bullet[1]; // bullets[0]=new Bullet(200,350); } ok 现在我们要实现英雄机的移动，英雄机的移动有两种移动，一种是鼠标控制移动，一种是键盘控制移动，我这里是鼠标控制移动，ok 首先我们定义一个鼠标的位置，我们采取英雄机的中心点作为鼠标的位置， 所以我们在Hero类里添加moveTo方法来确定鼠标的位置 public void moveTo(int x,int y){ this.x=x-width/2; this.y=y-hight/2; } 在acthion方法里添加鼠标移动事件处理， public void action(){ MouseAdapter l=new MouseAdapter(){ @Override public void mouseMoved(MouseEvent e){ int x=e.getX(); int y=e.getY(); hero2.moveTo(x,y); } }; this.addMouseMotionListener(l);//处理鼠标滑动动作 //上面为添加的代码 timer =new Timer();//主流程控制 timer.schedule(new TimerTask(){ @Override public void run(){ enterAction();//飞行物入场 stepAction();//走一步 repaint();//重绘 } } ,intervel,intervel); } 接下来实现子弹击打飞行物，思考一个问题，怎么来实现子弹击中飞行物呢，坐标，子弹坐标的是否在飞行物内，拿蜜蜂来说，若想我们的子弹击中蜜蜂，满足的条件是子弹的x坐标在蜜蜂的x坐标和x+width之间，同时满足子弹的y坐标在蜜蜂的y坐标和y+hight内 因为我们的飞行物和蜜蜂都可以被子弹击中，所以首先在父类FlyingObject中添加shootBy方法 public boolean shootBy(Bullet bullet){ this.x=bullet.x; this.y=bullet.y; return this.x&lt;x &amp;&amp; x&lt;this.x+width &amp;&amp; this.y&lt;y &amp;&amp; y&lt;this.y+hight; } 击中蜜蜂会有双倍活力或增加生命的奖励，所以在Hero添加两个方法 publi void addDoubleFire(){ doublefire+=40; } public void addLife(){ life++; } 在Airplane类里实现getScore方法，击中敌机给五分 public int getScore(){ return 5; } 在Bee类中添加getType，获得奖励的类型， public int getType(){ return awardType; } 在ShootGame类中添加score用来记录得分， private int score=0； 现在我们在ShootGame里添加bangAction和bang方法来实现检测子弹与飞行物的碰撞 首先我们需要先遍历所有的子弹 public void bangAction(){ for(int i=0;i&lt;bullet.length;i++){ Bullet b=bullet[i]; bang(b); } } 实现bang方法来检测是否相撞， public void bang(Bullet bullet){ int index=-1; for(int i=0;i&lt;flying.length;i++){ FlyingObject obj=flying[i]; if(obj.ShootBy(bullet)){ index=i; break; } } if(index!=-1){ FlyingObject one=flying[index]; FlyingObject temp=flying[flying.length-1]; flying[index]=flying[flying.length-1]; flying[flying.length-1]=temp; flyling=Arrays.copyOf(flyling,flyling.length-1); if(one instanceof Enemy){ Enemy e=(Enemy)one; score+=e.getScore(); } if(one instanceof Award){ Award a=(Award)one; int type=a.getType(); switch (type){ case Award.DOUBLE_FIRE: hero2.addDoubleFire(); break; case Award.LIFE: hero2.addLife(); break; } } } } 在action方法中调用bangAction； public void action(){ timer =new Timer();//主流程控制 timer.schedule(new TimerTask(){ @Override public void run(){ enterAction();//飞行物入场 stepAction();//走一步 shootAction(); bangAction() repaint();//重绘 } } ,intervel,intervel);} 接下来就是画我们的分数和生命值在我们的窗口左上角， 首先在我们的Hero里添加getLife public int getLife(){ return life; } ok,接下来我们在我们在ShootGame类中添加paintScore方法，用来绘画分数和生命值 public void paintScore(Graphics g){ int x=10; int y=25; Font font=new Font(Font.SANS_SERIF,Font.BOLD,14); g.setColor(new Color(0x3A3B3B)); g.setFont(font); g.drawString(&quot;SCORE:&quot;+score,x,y); y+=20; g.drawString(&quot;LIFE:&quot;+hero2.getLife(),x,y);} 并且在ShootGame类的paint方法中调用paintScore public void paint(Graphics g){ g.drawImage(background,0,0,null);//画背景图， paintHero(g);//画英雄机 paintBullets(g);//画子弹 paintFlyingObjects(g);//画飞行物 **paintScore(g)**//画生命值和分数 } ok，下一步，我们来把越界的飞行物、子弹删掉， 首先我们需要在父类FlyingObject类中添加一个抽象方法outOfBounds来判断飞行物、子弹是否越界 public abtrct boolean outOfBounds(); 分别在各类中添加这个方法(提示，由于outOfBounds是抽象方法所以每个它的子类都必须有这个方法，如果改子类不需要该方法，那么直接归还一个false即可)； 我举一个，剩下的我放在源码里 拿Bee来吧， @Override public boolean outOfBounds(){ return y&gt;ShootGame.HIGHT; } 接下来我们就把越界的飞行物删除，在ShootGame来中添加outOfBoundsAction方法 用FlyingObjectv创建一个flyingLiver类，用来存储没用越界的飞行物 然后再循环遍历所有的飞行物，并判断是否越界，并将没有越界的飞行物放到数组flyingLiver中 子弹和上述过程类似； public void outOfBoundsAction(){ int index=0; FlyingObject flyingLiver[]=new FlyingObject[flyling.length]; for(int i=0;i&lt;flyling.length;i++){ FlyingObject f=flyling[i]; if(!f.outOfBounds()){ flyingLiver[index++]=f;//没有越界的放到数组中 } } flyling=Arrays.copyOf(flyingLiver,index);//将不越界的飞行物从flyingLiver数组转移到flying中 index=0; Bullet []bulletLiver=new Bullet[bullets.length]; for(int i=0;i&lt;bullets.length;i++){ Bullet b=bullets[i]; if(!b.outOfBounds()){ bulletLiver[index++]=b; } } bullets=Arrays.copyOf(bulletLiver,index); } 在action方法里添加outOfBoundsAction方法 @Override public void run(){ enterAction();//飞行物入场 stepAction();//走一步 outOfBoundsAction()//删除飞行物和子弹 repaint();//重绘 } } ,intervel,intervel); } 现在我们来实现我们的本机Hero与飞行物和子弹相撞时，减生命和减子弹的倍数 首先在Hero类中添加两个方法用来减生命和子弹的倍数 public void setDoubleFire(int doubleFire){ this.doubleFire=doubleFire; } public void sebtrcatLife(){ life--; } 接下来再Hero类中添加hit来判断是否相撞 public boolean hit(FlyingObject other){ int x1=other.x-this.width/2; int x2=other.x+other.width+this.width/2; int y1=other.y-this.hight/2; int y2=other.y+other.hight+this.hight/2; return this.x+this.width/2&gt;x1&amp;&amp;this.x+this.width/2&lt;x2&amp;&amp;this.y+this.hight/2&gt;y1&amp;&amp;this.y+this.hight/2&lt;y2; } 在ShootGame类中添加isGameOver方法来判断游戏是否结束 第一步循环遍历所有的飞行物， 第二步判断飞行物是否与主机相撞，如果相撞，则生命值减一，且子弹倍数减倍， 然后记录相撞的飞行物，并将它清除 public boolean isGameOver(){ for(int i=0;i&lt;flying.length;i++){ int index=-1; FlyingObject obj=flying[i]; if(hero.hit(obj)){ hero.setDoubleFire(0); hero.sebtrcatLife(); index=1; } if(index!=-1){ FlyingObject t=flying[index]; flying[index]=flying[flying.length-1]; flying[flying.length-1]=t; flyling=Arrays.copyOf(flyling,flyling.length-1); } } return hero.getLife()&lt;=0; } 最后实现游戏的开始，运行，以及结束， 我们有开始，运行，暂停，结束四个状态，所以首先在ShootGame类中添加这四个属性 private int state; private static final int START=0; private static final int RUNNING=1; private static final int PAUSE=2; private static final int GAME_OVER=3; 在ShootGame类中添加checkGameOverAction检查游戏是否结束 public void checkGameOverAction(){ if(isGameOver){ state=GAME_OVER; } } 修改action，添加鼠标的点击，移动和移出，黑色字体为添加代码 public void action(){ MouseAdapter l=new MouseAdapter(){ @Override public void mouseMoved(MouseEvent e){ if(state==RUNNING){ int x=e.getX(); int y=e.getY(); hero2.moveTo(x,y); } } @Override public void mouseEntered(MouseEvent e){ if(state==PAUSE){ state=RUNNING; } } @Override public void mouseExited(MouseEvent e){ if(state!=GAME_OVER){ state=PAUSE; } } @Override public void mouseClicked(MouseEvent e){ switch (state) { case START: state=RUNNING; break; case GAME_OVER: flyling=new FlyingObject[0]; bullets=new Bullet[0]; hero2=new Hero(); score=0; state=START; break; } } }; this.addMouseListener(l);//处理鼠标点击动作 this.addMouseMotionListener(l);//处理鼠标滑动动作 timer =new Timer(); timer.schedule(new TimerTask(){ @Override public void run(){ if(state==RUNNING){ enterAction(); stepAction(); shootAction(); bangAction(); outOfBoundsAction(); checkGameOverAction(); } repaint(); } } ,intervel,intervel); } 然后把三个图画上去，分别是开始，暂停和结束在ShootGame类添加paintState方法 public void paintState(Graphics g){ switch (state){ case START: g.drawImage(start,0,0,null); break; case PAUSE: g.drawImage(pause,0,0,null); break; case GAME_OVER: g.drawImage(gameover,0,0,null); break; } } 并在paint方法里调用该方法 @Override public void paint(Graphics g){ g.drawImage(background,0,0,null); paintHero(g); paintBullets(g); paintFlyingObjects(g); paintScore(g); paintState(g); } 我在编程中遇到的最大的问题就是贴背景哪里，因为写错犯的错，越是简单的代码越要仔细看一下，ok，结束]]></content>
  </entry>
  <entry>
    <title><![CDATA[纯净水的独白]]></title>
    <url>%2F2018%2F07%2F15%2F%E7%BA%AF%E5%87%80%E6%B0%B4%E7%9A%84%E7%8B%AC%E7%99%BD%2F</url>
    <content type="text"><![CDATA[风起了，要出海了 立好flag，就走吧，毕竟有人在等 滴答·滴答，时间不多，还有一个多月，Java、DataStructure、MySql、English也稍稍进入了状态(还是有人带着好呀,总算把懒惰的毛病稍稍改了) 简单说一下进展和计划吧！ ｊａｖａ java的进展跟着基础篇的进行，现在进入了做一些有意思的小程序阶段，做这些小程序实现起来还是很有意思的，接下来的java计划就是继续跟着书学习，争取在两个月后可以写一些好玩的小游戏。 ＤａｔａＳｔｕｃｔｕｒｅ 数据结构现在进入了链表，之前的数组和它的子集栈、队列，里面的逻辑学到守了，做了三道题，一道数组的，两道栈的，虽然不是很成功，但是还是对学习和理解有很大的帮助，接下来就继续跟着老师走，争取学到第八个吧。 ＭｙＳｑｌsql的那本书看完了,接下来就先写个简单的数据库管理系统(用sql写,牛掰了再用java写)。 Ｅｎｇｌｉｓｈ 选对了书呀，看的越来越感兴趣，两个月后应该可以看完，nice。 废话不多说就是“干”＋！Ｆｉｇｈｔｉｎｇ！！！]]></content>
  </entry>
  <entry>
    <title><![CDATA[你好,世界]]></title>
    <url>%2F2018%2F07%2F04%2F%E4%BD%A0%E5%A5%BD-%E4%B8%96%E7%95%8C%2F</url>
    <content type="text"></content>
  </entry>
</search>
